// import base YAML parser.
import parser, { ast, createNode } from 'yaml';
import { get, set, first, each } from 'lodash';

/**
 * Interface YAMLBuilderOptions.
 */
export interface YAMLBuilderOptions {
  // header message.
  header: string;
  // docker-compose syntax version number.
  version: string;
  // list of compose services.
  services: object[];
  // list of compose volumes.
  volumes: object[];
  // list of networks.
  networks: object[];
}

/**
 * Class YAMLBuilder.
 *
 * helps building docker-compose YAML file.
 */
export class YAMLBuilder {
  // compose file header.
  public header: string = null;

  // compose syntax version.
  public version: string = '3.6';

  // compose services list.
  public services: object[];

  // list of compose volumes.
  public volumes: object[];

  // document instance.
  public document: parser.ast.Document;

  // constructor.
  public constructor(options: YAMLBuilderOptions) {
    // assign header message
    this.header = options.header || 'Generated By Ambientum CLI';
    // assign compose syntax version.
    this.version = options.version;
    // assign compose services.
    this.services = options.services;
    // assign compose volumes.
    this.volumes = options.volumes;
    // start an empty YAML document.
    this.document = new parser.Document();
  }

  // render to YAML document.
  public toDocument() {
    // initialize document contents with an empty node.
    const data = parser.createNode({
      version: this.version,
      services: {},
      volumes: {},
    }) as ast.Map;

    // get first item.
    const version = data.items[0] as ast.Pair;
    const services = data.items[1] as ast.Pair;
    const volumes = data.items[2] as ast.Pair;



    // insert empty line on node.
    // @ts-ignore
    version.spaceBefore = true;
    // add node comment.
    version.commentBefore = ' compose syntax version.';

    // insert empty line on node.
    // @ts-ignore
    services.spaceBefore = true;
    // add node comment.
    services.commentBefore = ' services declaration';

    // loop services.
    each(this.services, (data) => {
      // parse data.
      const name = get(data, 'name');
      const comment = get(data, 'x-comment', null) || name;
      const volume = get(data, 'data');
      // create the node wrapping.
      const nodeWrapper = parser.createNode(set({}, name, volume)) as ast.Map;
      // get first item on the wrapper.
      const node = nodeWrapper.items[0];
      // create an empty space before.
      // @ts-ignore
      node.spaceBefore = true;
      // add a comment.
      node.commentBefore = ' ' + comment;
      // push service.
      (services.value as ast.Map).items.push(node);
      return node;
    });
    // insert empty line on node.
    // @ts-ignore
    volumes.spaceBefore = true;
    // add node comment.
    volumes.commentBefore = ' volumes declaration';

    // loop volumes.
    each(this.volumes, (data) => {
      // parse data.
      const name = get(data, 'name');
      const comment = get(data, 'x-comment', null) || name;
      const volume = get(data, 'data');
      // create the node wrapping.
      const nodeWrapper = parser.createNode(set({}, name, volume)) as ast.Map;
      // get first item on the wrapper.
      const node = nodeWrapper.items[0];
      // create an empty space before.
      // @ts-ignore
      node.spaceBefore = true;
      // add a comment.
      node.commentBefore = ' ' + comment;
      // push service.
      (volumes.value as ast.Map).items.push(node);
      return node;
    });

    // assign document contents.
    this.document.contents = data;
    // add banner / header message as being document comment itself.
    this.document.commentBefore = this.header.split('\n').map((line: string) => ` ${line}`).join('\n');


    return this.document;
  }

  // render document as string.
  public toString() {
    // call object conversion then string conversion.
    return (this.toDocument().toString());
  }
}
