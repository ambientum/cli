// module exports.
import { DockerComposeService } from 'lib/support/compose/DockerComposeService';
import { DockerComposeVolume } from 'lib/support/compose/DockerComposeVolume';
import parser, { ast } from 'yaml';
import { get, set, each, first } from 'lodash';
import { IYAMLBuilderOptions } from 'lib/support/compose/types';

// Class YAMLBuilder.
export class YAMLBuilder {
  // compose file header.
  public header: string = null;

  // compose syntax version.
  public version: string = '3.6';

  // compose services list.
  public services: DockerComposeService[];

  // list of compose volumes.
  public volumes: DockerComposeVolume[];

  // list of compose networks.
  public networks: object[];

  // document instance.
  public document: parser.ast.Document;

  // constructor.
  public constructor(options: IYAMLBuilderOptions) {
    // assign header message
    this.header = options.header || 'Generated By Ambientum CLI';
    // assign compose syntax version.
    this.version = options.version;
    // assign compose services.
    this.services = options.services;
    // assign compose volumes.
    this.volumes = options.volumes;
    // start an empty YAML document.
    this.document = new parser.Document();
  }

  // render to YAML document.
  public toDocument() {
    // add banner / header message as being document comment itself.
    this.addComment(this.document, this.header, false);

    // initialize document contents with an empty node.
    this.document.contents = parser.createNode({
      version: this.version,
      services: {},
      volumes: {},
    }) as ast.Map;

    // -- prepare version section.
    // compose version is at index 0.
    const version = this.document.contents.items[0] as ast.Pair;
    // add comment on version.
    this.addComment(version, 'compose syntax version.', true);


    // -- prepare services section.
    // compose services is at index 1.
    const services = this.document.contents.items[1] as ast.Pair;
    // add main.
    this.addComment(services, 'services declaration.', true);
    // prepare resources and push into AST tree.
    this.prepareResources(this.services, services.value as ast.Map);

    // -- prepare volumes section.
    // compose volumes is at index 2.
    const volumes = this.document.contents.items[2] as ast.Pair;
    // add main.
    this.addComment(volumes, 'volumes declaration.', true);
    // prepare resources and push into AST tree.
    this.prepareResources(this.volumes, volumes.value as ast.Map);

    // complete by returning ast.Document instance.
    return this.document;
  }

  // render document as string.
  public toString() {
    // call object conversion then string conversion.
    return (this.toDocument().toString());
  }

  // add a comment on a given node.
  // space before indicates if a new line should be before the node.
  protected addComment(node: ast.Document|ast.Map|ast.Pair|ast.Merge, comment: string, spaceBefore: boolean = false) {
    // add comment on the node. each line gets a empty space before.
    node.commentBefore = comment.split('\n').map((line: string) => ` ${line}`).join('\n');
    // add space before the node.
    // @ts-ignore.
    node.spaceBefore = spaceBefore;
  }

  // prepare services.
  protected prepareServices(targetMap: ast.Map) {
    // loop services.
    each(this.services, (v: DockerComposeService) => {
      // serialize service.
      const data = v.serialize();
      // get service name.
      const name = get(data, 'name');
      // create the AST node.
      const node = first((parser.createNode(set({}, name, get(data, 'data'))) as ast.Map).items);
      // add volume comments.
      this.addComment(node, (get(data, 'x-comment', null) || name), false);
      // push built service node into AST tree.
      targetMap.items.push(node);
    });
  }

  protected prepareResources(resources: DockerComposeService[]|DockerComposeVolume[], targetMap: ast.Map) {
    // loop services|volumes.
    each(resources, (v: DockerComposeService|DockerComposeVolume) => {
      // serialize service|volume.
      const data = v.serialize();
      // get service|volume name.
      const name = get(data, 'name');
      // create the AST node.
      const node = first((parser.createNode(set({}, name, get(data, 'data'))) as ast.Map).items);
      // add service|volume comments.
      this.addComment(node, (get(data, 'x-comment', null) || name), false);
      // push built service|volume node into AST tree.
      targetMap.items.push(node);
    });
  }
}
